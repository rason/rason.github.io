title: 页面置换算法
categories: OS
date: 2016-10-17 16:27:05
tags: 页面置换算法
description: 页面置换算法
---

## 前言

在前面的学习中，我们知道当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。那么，如何选择被换出的页面将是我们今天要讨论的内容。

其实，**页面置换**问题在计算机设计的其他领域中也同样会发生。比如说Web服务器，服务器可以把一定数量的经常访问的Web页面放在存储器的高速缓存中。但是，当存储器高速缓存已满并且要访问一个不在高速缓存中的页面时，就必须要置换高速缓存中的某个页面。

## 最优页面置换算法

> 在缺页中断发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要到10，100或1000条指令后才会被访问，每个页面都可以用**在该页面首次被访问前所要执行的指令数**作为标记。最优页面置换算法规定应该置换标记最大的页面。

可是，这个算法无法实现。当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。

## 最近未使用页面置换算法

在前面学习的页表项中有访问位和修改位，当页面被访问（读或写）时设置访问位（假设为R位）；当页面（即修改页面）被写入时设置修改位（假设为M位）。

> 我们可以用R位和M位来构造一个简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由操作系统设置成0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。

当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位值，把它们分为4类：

- 第0类：没有被访问，没有被修改。
- 第1类：没有被访问，已被修改。
- 第2类：已被访问，没有被修改。
- 第3类：已被访问，已被修改。

**NRU (Not Recently Used,最近未使用)算法随机地从类编号最小的非空类中挑选一个页面淘汰之。**这个算法隐含的意思是，在最近一个时钟滴答中（典型的时间是大约20ms）淘汰**一个没有被访问的已修改页面要比淘汰一个被频繁使用的”干净“页面好。**NRU主要优点是易于理解和能够有效地被实现，虽然性能不是很好，但是够用。

## 先进先出页面置换算法

> 由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最久进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。

这种方式可能会把经常使用的页面置换出去，所以很少使用纯粹的FIFO算法。

## 第二次机会页面置换算法

> 为了弥补FIFO算法的缺陷，对该算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续搜索。这一算法称为**第二次机会（second chance）算法**。

第二次机会算法就是**寻找一个最近的时钟间隔以来没有被访问过的页面**。

## 时钟页面算法

尽管第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。一个更好的办法是把所有页的页面都保存在一个类似钟面的环形链表中，一个表针指向**最老的页面**，如下图所示。

![时钟页面置换算法](/image/clock-alg)

<!-- more -->

## 最近最少使用页面置换算法

> 对最优算法的一个很好的近似是基于这样的观察：在前面几条指令中频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。这个思想提示了一个可实现的算法：在缺页中断发生时，置换未使用时间最长的页面。这个策略称为LRU （Least Recently Used，最近最少使用）页面置换算法。

虽然LRU在理论上可以实现，但是完全实现LRU代价较高，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次访问内存时都必须更新整个链表，这将会非常耗时。

然而，可以使用一些特殊硬件来实现LRU，一般有两种方式：

- 一个64位的硬件计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的C值保存到被访问页面的页表项中。发生缺页中断时，就置换值最小的那个页面。

- 内存为n个页框的机器中，硬件维护一个初始值为0的n*n位的矩阵。当访问页框k时，硬件首先把k行的位都设置为1，再把k列的位都设置成0。在任何时刻，二进制值最小的行就是最近最少使用的。

## 用软件模拟LRU

前面两种LRU算法虽然可以实现，但是只有非常少的计算机拥有这种硬件。因此需要一个能用软件实现的解决方案。

一种可能解决方案称为**NFU（Not Frequently Used，最不常用）算法**，该算法将每个页面于一个软件计数器关联，计数器的初始值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它的值是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。

NFU算法存在一个问题，如果一个页面之前比较频繁用到，值就比较大；在后面的扫描中，其实它有可能已经没用到了，但是用到的页面的值没它大，然后反而会把用到的置换了。可以将NFU算法修改两部分，变成老化算法：

> 首先，在R位被加进之前要先将计数器右移一位；其次，将R位加到计数器的最左端的位而不是最右端。发生缺页中断时，则置换计数器值最小的页面。这个算法称为**老化算法**。

举个例子，假设页面0到页面5的初始值都是0，在第一个时钟周期内访问了页面0,2,4,5，它们的R位设置为1，其它页面的R位仍为0。如下图所示：

![用软件模拟的LRU老化算法](/image/aging-alg)

要注意的是，老化算法的计数器只有有限位数（本例中是8位），这就限制了其对以往页面的记录。如果两个页面的计数器都是0，我们只能在两个页面中随机选一个进行置换。实际上，有可能其中一个页面上次被访问是在9个时钟周期以前，另一个页面是在1000个时钟周期之前，我们无法看到这些。在实践中，如果时钟周期是20ms，8位一般是够用的。

## 工作集置换算法

在单纯的分页系统中，程序在刚启动时，在内存中并没有页面。在CPU访问第一条指令时就产生缺页中断，然后操作系统装入含有该指令的页面。其他的页面也是如此，在用到的时候再装入，这种策略称为**请求调页**。

在多道程序设计中，经常会把进程转移到磁盘上（即从内存中移走所有的页面），这样可以让其他的进程有机会占有CPU。然而，当进程再次调回来的时候该怎么办？又一次像上面那样用到再加载？拜托，那样太慢了，因为处理太多次的缺页中断CPU耗时太长了，白白浪费了CUP时间。若执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了**颠簸**。 	因此才出现了工作集的概念，一次性装载多个页面。

那么，什么是工作集？**一个进程在时间t的工作集W(t,τ)定义为在时间段(t-τ ,t)内进程所使用的页面的集合。**通俗地讲就是某个时间段内使用过的页面的集合。

所以不少分页系统都会设法跟踪进程的工作集，已确保让进程运行以前，它的工作集就已在内存中了。这种方法称为**工作集模型**，其目的在于大大减少缺页中断率。在让进程运行前预先装入其工作集页面也称为**预先调页**。

> 利用工作集模型，可以推导出一个合理的页面置换算法：当发生缺页中断时，淘汰一个不在工作集的页面。

那么，如何实现基于工作集的页面置换算法？在页表项中记录两条信息：**上次使用该页面的近似时间和R（访问）位。**如下图所示：

![工作集算法](/image/working-set-alg)

该算法的工作方式如下：当发生缺页中断时，扫描页表已找出一个合适的页面淘汰之。淘汰方式见图中文字。如果扫描完全部页表都没有找到适合被淘汰的页面，也就意味着所有的页面都在工作集中。在这种情况下，如果找到一个或多个R=0的页面，就淘汰生存时间最长的页面。如果所有页面都被访问过，则随机选择淘汰一个页面，如果有的话最好选一个干净的页面。

## 工作集时钟页面置换算法

由于工作集算法需要扫面全部的页面，比较费时。于是在工作集算法上改进，不扫描全部页面，只扫描在内存中的页面，即页框， 所有页框形成一个环，每个表项包括上次使用时间，R位M位。

缺页中断时，首先检查指针指向的页面，若R位==1，则说明它最近被访问了，把R位置为0，指针指向下一个位置；若R==0，若它的生存时间>t且此页面干净，置换之；如果不干净，继续往前走。（因为可能前方存在旧的又干净的页面）。

## 总结

![页面置换算法总结](/image/pages-replacement-alg-summary)

需要提到的是，LRU算法是一种非常优秀的算法，但是只能通过特定的硬件来实现。NFU是一种近似于LRU的算法，它的性能不是非常好，然而，老化算法更近似于LRU并且可以更有效地实现。

总之，最好的两种算法是老化算法和工作集时钟算法，它们分别基于LRU和工作集。
