title: 优先队列
categories: Algorithm
date: 2016-07-06 09:22:12
tags: 优先队列 Algorithm 
description: 优先队列
---

## 前言

考虑一个问题：输入N个字符串，每个字符串都对应着一个整数，你的任务就是从中找出最大的（或者最小的）M个整数（及其关联的字符串）。这些输入可能是金融事务，你需要从中找出最大的那些；或是农产品中的杀虫剂含量，这时你需要从中找出最小的那些等等。你会怎么解决这类问题？

根据前面学习的排序，我们可能会先将输入排序，然后取出M个最大的元素，但是我们已经说明了输入将会非常庞大。

另一种方法是将每个新的输入和已知的M个最大元素比较，先将元素插入，然后比较删除最小的，这样一来就可以保存M个最大元素了。但是，这种方法需要我们实现高效的insert()和delMin()方法，否则的话这种每次都比较的代价也是非常高的。

这里的第二种方法，就是今天所要说的**优先队列**。

## 优先队列API

根据上面的分析，我们可以抽象出优先队列的API大致如下所示：

```
public class MaxPQ<Key extends Comparable<Key>> {

	public MaxPQ(Key[] a);//使用数组初始化一个优先队列
	
	public MaxPQ(int size);//创建一个容量为size的优先队列
	
	public MaxPQ();
	
	public Key max();//返回最大值
	
	public Key delMax();//删除最大值
	
	public void insert(Key k);//插入一个元素

	public int size();//返回优先队列的大小

	public boolean isEmpty();//判断队列是否为空

}
```
这里我们举出的例子是MaxPQ，但它的实现很容易转化为MinPQ，只需要改变一下less()比较的方向即可。

**优先队列的用例：**

```
public class TopM{
	public static void main(String[] args){
		int M = Integer.parseInt(args[0]);
		MinPQ<Transaction> pq = new MinPQ<Transaction>(M + 1);
		while(StdIn.hasNextLine()){
			pq.insert(new Transaction(StdIn.readLine()));
			if(pq.size > M){
				pq.delMin();
			}
		}

		Stack<Transaction> stack = new Stack<Transaction>();
		while(!pq.isEmpty())
			stack.push(pq.delMin);
		for(Transaction t : stack)
			StdOut.println(t);
	}
}
```

这段代码的作用就是当优先队列的大小超过M时就删除掉最小的元素，所有事务输入完毕后程序从优先队列中按递减顺序打印出最大的M个事务。

<!-- more -->

## 优先队列的初级实现

前言中已经说了，使用优先队列的前提就是我们能够高效的实现insert()和delMin()方法，如果这两个方法不高效的话使用优先队列的代价也是很大的。首先我们能想到的应该是用基础的数据结构数组和链表来实现，可以有序也可以无序。

- **数组的实现（无序）**：既然是无序的当然在插入的时候随意插入，但是在删除的时候就需要进行比较删除最大元素了（可以使用类似选择排序的内循环代码）。

- **数组的实现（有序）**：有序的实现就是在插入的时候将其排好序，这样数组最大的元素肯定就在数组的一边；删除的时候直接将边界那个元素删除就行了。

使用链表的方式也类似，你会发现有序和无序这两种方式，在insert()和delMin()这两个方法的实现中总有一个方法会比较复杂。即**插入元素和删除最大元素这两个操作之一在最坏情况下需要线性时间来完成**，如下图所示：

![优先队列初级实现在最坏情况下运行时间的增长数量级](https://raw.githubusercontent.com/rason/rason.github.io/master/image/priorityqueue1)

那么，有没有什么方式能够保证两种操作都能更快地进行操作？答案就是：**堆**。


## 堆的定义

在理解二叉堆的定义之前，我们先了解一下堆有序：当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**。

### 二叉堆表示法

试想一下，我们用什么方法可以把一棵堆有序的二叉树描述出来？

首先我们能想到的是不是指针的方式？每个元素都需要三个指针来找到它的上下结点（父结点和两个子节点各需要一个），可是这样是不是很麻烦？

如果使用完全二叉树，那就只用数组不需要指针就可以表示。具体方法就是将二叉树的结点按**层级顺序**放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。

**定义：**二叉堆是一组能够用堆有序的完全二叉树排序的元素，并且在数组中按照层级存储（不使用数组的第一个位置）。

....
....
....

现在二叉堆的定义我们已经理解了，现在要研究的就是它如何能够提升优先队列插入和删除的性能了。但是在此之前我们还得了解一些基本的知识：

- 位置k的结点的父结点的位置为k/2,两个子结点的位置分别为2k和2k+1
- 我们可以通过数组的索引在树中上下移动元素：从a[k]向上一层就令k等于k/2,向下一层则令k等于2k或2k+1

利用在数组中无需指针即可沿树上下移动的便利，算法可以保证**对数复杂度**的性能。

### 堆的算法

现在我们可以设想一下，在堆中插入元素或删除最大元素时，是不是会打乱堆的顺序？这时我们需要将堆重新遍历恢复堆的状态，这一过程叫做**堆的有序化**。

所以，**如何高效地实现堆的有序化**就成了提高优先队列中插入元素和删除最大元素性能的关键了。

在堆的有序化过程中我们会遇到两种情况：

- 当某个结点的优先级上升(或是在堆底加入一个新的元素)时，我们需要**由下至上**恢复堆的顺序（结点上浮）。
- 当某个结点的优先级下降时（例如，将根结点替换为一个较少的元素）时，我们需要**由上至下**恢复堆的顺序（结点下沉）。

#### 由下至上的堆有序化（上浮）

如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。伪代码如下所示：

```
private void swim(int k){
	while(k > 1 && less(k/2,k)){
		exch(k/2,k);
		k = k/2;
	}
}
```

#### 由上至下的堆有序化（下沉）

如果对的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。。伪代码如下所示：

```
private void sink(int k){
	while(2*k <= N){
		int j = 2*k;
		if(j < N && less(j,j+1))
			j++;
		if(!less(k,j))
			break;
		exch(k,j);
		k = j;
	}
}
```

有了这两个方法，我们就能高效地实现优先队列的API了。

- **插入元素：**我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。
- **删除最大元素：**我们从数组顶端删除最大的元素并将数组的最后一个元素放到顶端，减少堆的大小并让这个元素下沉到何时的位置。

## 基于堆的优先队列

```
public class MaxPQ<Key extends Comparable<Key>> {
	private Key[] pq;
	private int N = 0; // 存储于pq[1...N],pq[0]没有使用
	
	public MaxPQ(int size){
		N = size;
		pq = (Key[]) new Comparable[size + 1];
	}
	
	public Key max(){
		return pq[1];
	}
	
	public Key delMax(){
		Key max = pq[1];
		exch(1,N--);
		pq[N+1] = null;
		sink(1);
		return max;
	}
	
	public void insert(Key k){
		pq[++N] = k;
		swin(N);
	}
	
	public int size(){
		return N;
	}
	
	public boolean isEmpty(){
		return N == 0;
	}
	
	private void exch(int i,int j){
		//略
	}
	private void swin(int k){
		//见上
	}
	private void sink(int k){
		//见上
	}

}
```

**对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN次比较。**这个结论可以根据完全二叉树的高度可以得出。大小为N的完全二叉树高度为lgN，上浮操作每次都跟上一层的根节点比较，是不是有多少层最差就需要比较多少次？下沉操作要跟下层的两个元素比较，所以最差每层都需要比较就是2lgN。

对于需要大量混杂的插入和删除最大元素的典型应用来说，使用有序或是无序的数组的优先队列的初级实现总是需要线性实际来完成其中一种操作，但基于对的实现则能够保证在对数实际内完成它们。

## 总结

本文讨论的就是从N个输入中找到最大的M个元素所需成本的问题，如下图所示：

![从N个输入中找到最大的M个元素所需成本](https://raw.githubusercontent.com/rason/rason.github.io/master/image/priorityqueue2)

