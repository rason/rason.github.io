title: 快速排序
categories: Algorithm
date: 2016-07-04 11:06:45
tags: Algorithm
description: 快速排序
---

## 前言

快速排序可能是应用最广泛的排序算法了，它适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。快速排序引人注目的特点包括它是原地排序（只需要很小的辅助栈），且将长度为N的数组排序所需的实际和NlgN成正比。在前几篇文章中的排序算法都无法将这两个优点结合起来。主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。

## 快速排序

快速排序和归并排序一样，也是一种分治的排序算法。但是快速排序并不是将数组对半分，而快速排序中的切分位置是不确定的。那么快速排序是根据什么条件切分数组？

假设切分的位置索引是j，那么快速排序切分数组需要满足的条件如下：

- a[j]的位置就已经是固定的了
- a[j]左边部分数组的值都小于或等于a[j]
- a[j]右边部分数组的值都大于或等于a[j]

这样一来，每一次切分是不是就确定了a[j]这个位置，然后分别对左右两边数组再分别进行递归切分，整个数组是不是就排序完成了？所以，**快速排序算法的突破口就在于如何确定这个切分点a[j]了**。

因此，快速排序的代码是不是就可以写成这样了：

```
public static void sort(Comparable[] a,int lo,int hi){
	if(lo >= hi)
		return;
	int j = partition(a,lo,hi); // 切分
	sort(a,lo,j - 1); // 左边部分排序
	sort(a,j + 1,hi); // 右边部分排序
}
```

重点就在于partition()方法如何实现了。一般策略是先随意地取a[lo]作为切分元素，即那个将会被排定的元素，然后我们从数组的左端开始扫描知道找到一个大于等于它的元素；再从数组的右端开始从左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧元素a[j]交换然后返回j即可。切分过程如下图所示：

![快速排序切分过程](https://raw.githubusercontent.com/rason/rason.github.io/master/image/quicksort1)

<!-- more -->

**切分的代码实现**

```
public static int partition(Comparable[] a,int lo,int hi){
	Comparable v = a[lo];
	int i = lo,j = hi + 1;
	while(true){
		while(less(a[++i], v)){
			if(i == hi)
				break;
		}

		while(less(v, a[--j])){
			if(j == lo)
				break;
		}

		if(i >= j)
			break;

		exch(a,i,j);
	}
	exch(a,lo,j);
	return j;
}
```

## 快速排序性能

快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性是快速排序的一个优点，很难想象排序算法中还能有比这更短小的内循环了。例如，归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。

快速排序另一个速度优势在于它的比较次数很少。排序效率最终还是依赖切分数组的效果，而这依赖于切分元素的值。切分将一个较大的随机数组分成两个随机子数组，而实际上这种分割可能发生在数组的任意位置（对于元素不重复的数组而言）。

结论1：**将长度为N的无重复数组排序，快速排序平均需要～2NlnN次比较（以及1/6的交换）。**2NlnN约等于1.39NlgN，也就是说平均比较次数只比最好情况多39%。

尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时这个程序可能会极为低效。例如，如果第一从最小的元素切分，第二次从第二小元素切分，这样每次只会移动一个元素。

结论2：**快速排序最多需要约N的平方/2次比较，但随机打乱数组能够预防这种情况。**

总的来说，可以肯定的是对于大小为N的数组，快速排序的运行时间在1.39NlgN的某个常数因子的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多39%），因为它移动数据的次数更少。

## 算法改进

### 切换到插入排序

和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：

- 对于小数组，快速排序比插入排序慢；
- 因为递归，快速排序的sort()方法在小数组中也会调用自己。

因此，我们只需要做简单的改动：

```
将if(lo >= hi) return;

改成if(hi <= lo + M){Insertion.sort(a,lo,ho); return;}

```

转换参数M的最佳值是和系统相关的，但是5~15之间的任意值在大多数情况下都能令人满意。

### 三向切分

实际应用中经常会出现含有大量重复元素的数组，这时快速排序有巨大的改进空间。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，可以将当前实现的线性对数级别的性能提高到线性级别。

一个简单的想法是将数组切分为三部分，分别对应小于、等于和大于切分元素的数组。切分过程如下图所示：

![三向切分排序切分过程](https://raw.githubusercontent.com/rason/rason.github.io/master/image/quicksort2)

**三向切分的代码实现**

```
public void sort(Comparable[] a,int lo,int hi){
	if(lo >= hi)
		return;
	int lt = lo,i = lo + 1,gt = hi;
	Comparable v = a[lo];
	while(i <= gt){
		int comp = a[i].compareTo(v);
		if(comp < 0)
			exch(a, lt++, i++);
		else if(comp > 0)
			exch(a, i, gt--);
		else
			i++;
	} // 现在a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]成立
	sort(a,lo,lt - 1);
	sort(a,gt + 1,hi);
}
```

三向切分是信息量最优的，即对于任意的分布的输入，最优的基于比较的算法平均所需的比较次数和三向切分的快速排序平均所需的比较次数互相处于常数因子范围之内。**对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。**

## 总结

本文学习了快速排序基本算法，其突破口就是找出切分点；另外还学习了快速排序的改进算法三向切分，三向切分分成了小于，等于，大于三部分；在含有大量重复元素的数组，三向切分排序时间能降低到线性级别。
