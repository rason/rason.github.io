## 序列化

|   方案   |  特点    |  适用场景 |
|:--------------:|:---------------:|:--------------:|
|XML|跨机器，跨语言，自我描述，人眼可读，无需IDL和第三方编译器，可基于HTTP传输协议具有良好的防火墙穿透性；缺点是时间空间开销都很大，不适用于性能要求很高的场景|O/R mapping， Spring Bean Configuration File，SOAP适用于公司之间传输数据量相对小或者实时性要求相对低的场景|
|JSON|无需IDL，自身就跨语言，跨平台，Associative array格式符合工程师对对象的理解，人眼可读，相对于XML更加简洁，解析速度更快，Javascript的先天性支持，所以很适用Web前端适用，Java后端可用反射的方式进行处理，比如Gson；缺点也是时间和空间开销都比较大|公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务，基于Web browser的Ajax请求，JSON具有非常强的前后兼容性，适用接口经常发生变化，并对可调式性要求高的场景|
|Thrift|高性能序列化和RPC框架，不仅仅是序列化协议，还是一个RPC框架；在空间开销和解析性能上有了比较大的提升，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP），所以在跨防火墙时存在安全问题；序列化后的数据是Binary数组，不具可读性，调试困难|对于需求为高性能，分布式的RPC服务，Thrift是一个优秀的解决方案；适用于作为公司内部的面向服务构建（SOA）的标准RPC框架|
|Protobuf|跟上面几种相比序列化之后的压缩率是最高的，解析速度最快，是一种相当好的序列化方案；可惜的是开源版本没有RPC框架实现，可以与Thrift的RPC框架结合使用|由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景|
|Avro|Avro的产生解决了JSON的冗长和没有IDL的问题，提供两种序列化格式：JSON格式或者Binary格式，Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试|适合于高性能的序列化服务，适合动态类型语言，适合于做Hive、Pig和MapReduce的持久化数据格式|

## 选型建议

以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：

1. 对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。

2. 基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。

3. 对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。

4. 当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。

5. 对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。

6. 由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。

7. 对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。

8. 如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。

9. 如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
