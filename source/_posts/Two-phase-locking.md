---
title: Two-phase locking
date: 2017-09-11 09:12:28
categories: Concurrency
tags: Concurrency
description: Two-phase locking
---

两阶段锁(Two-phase locking)是一种处理并发控制的方法，跟两阶段提交不一样，两阶段提交用于处理分布式事务或者数据库的原子提交问题。

在数据库和事务处理中，两阶段锁是一种在并发控制中保证**可串行化**的方法。两阶段锁协议利用事务对数据应用锁机制，这可能阻塞其他事务在该事务的生命周期中访问相同的数据。

在两阶段锁协议中，锁被应用与两个阶段：

- 1.扩展阶段：只能加锁，不能释放锁。
- 2.收缩阶段：只能释放锁，不能加锁。

在基本的协议中一般用到两种类型的锁：共享锁和排它锁。而在改进的协议中，可能会应用更多类型的锁。使用锁来阻塞进程，在两个互相阻塞的事务中，两阶段锁可能会导致死锁。

## 数据访问锁

锁是与共享资源，比如基本类型的数据项，数据库中的一行数据或者内存页相关联的**系统对象**。在数据库中，访问数据对象之前可能需要先获得在该数据对象上的锁(数据访问锁)。

正确地使用锁可以防止其他事务在共享资源上进行不被期望，不正确或者不一致的操作。当一个事务需要访问另一个事务持有锁的数据对象，系统会检测数据对象的锁是否已经被持有和锁的类型。如果现有的锁类型不允许进行并发访问，则该尝试访问的事务会被阻止。

实际上，对象上的锁定并不直接阻止事务在对象上的操作，而是阻止该事务从同一对象获取另一个锁，在执行此操作之前需要由事务持有。 

两种类型的锁：

- **写锁(排它锁)**：对数据对象进行写(插入/修改/删除)操作之前，写锁由事务与数据对象相关联。
- **读锁(共享锁)**：读取数据之前，读锁由事务与数据对象相关联。

这两种锁的相互关系和阻塞行为如下：

- 一个事务获取了数据对象的写锁，另一个事务在该对象的写操作会被阻塞。
- 一个事务获取了数据对象的写锁，另一个事务在该对象的读操作会被阻塞。
- 一个事务获取了数据对象的读锁，另一个事务在该对象的写操作会被阻塞。
- 一个事务获取了数据对象的读锁，另一个事务在该对象的读操作不会被阻塞。

如果第一个锁阻塞另一个锁，那么这两个锁称为不兼容，否则称为兼容。

| Lock type | read-lock | write-lock |
| ------| ------ | ------ |
| read-lock |  | X |
| write-lock | X | X |

## 两阶段锁和它的特殊情况

### 两阶段锁

根据两阶段锁定协议，一个事务在事务的执行过程中处理其两个不同的连续阶段的锁：

- 1.**扩展阶段**：锁只能被获得，不能被释放。
- 2.**收缩阶段**：锁只能被释放，不能被获得。

两相锁定规则可以归纳为：不要在释放锁之后获取锁。对于具有遵守此规则的事务，可以保证串行化属性。

通常，在不明确事务的第一阶段何时结束的情况下，在事务最终完成和请求提交之后一次性释放锁会比较安全。

### 保守两阶段锁

保守两阶段锁与两阶段锁的不同之处就是在事务开始之前先获得所有的锁。这是为了确保事务能够持有所需要的锁而不被阻塞。保守两阶段锁可以避免死锁。

### 严格两阶段锁

为了符合S2PL协议，事务需要符合2PL，并且只有在结束之后释放其写锁，即被提交或中止。另一方面，读锁在阶段2期间定期释放。

## 可串行化

上面提到二阶段锁是保证可串行化属性的的方法。那么什么是可串行化？

在理解可串行化之前我们首先要明白什么叫调度，**调度（schedule）**指数据库要执行多项事务，每项事务包括好几条指令，先执行什么指令后执行什么指令的安排。

但是指令的安排顺序（即调度）不同，事务的执行结果也不同。我们必须有一个标准来判断某种调度是否正确。这个标准就是事务串行——先执行事务1的所有指令，再执行事务2的所有指令——后的结果。如果调度结果与串行结果相同，则调度正确；反之则错误。此概念与操作系统中多线程的执行类似。

对于正确的调度，我们给它一个形容词，说此调度是可串行的（Serializable）。可串行的是英文直译，更准确的词可以是“串行等价的”，即该调度的结果与事务串行的结果是相等的。

- 如果两项事务只是读数据，则指令的执行顺序是无关紧要的；
- 如果两项事务读写不同的数据，则指令的执行顺序是无关紧要的；
- 如果两项事务读写同一条数据，则指令的执行顺序是重要的。我们把这两项事务称为冲突的事务。

第（1）（2）两类事务的任何调度，都是串行等价的。对于第（3）类事务，如果调度正确，我们可以说此调度是冲突可串行的（Conflict Serializable），更准确的说法可以是“冲突串行等价的”，表示该调度的结果与冲突（的事务）串行的结果是相等的。冲突串行等价的是串行等价的的子类。
