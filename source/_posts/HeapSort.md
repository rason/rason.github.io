title: 堆排序
categories: Algorithm
date: 2016-07-19 11:17:50
tags: 排序
description: Algorithm 堆排序
---

## 前言

上一篇文章中学习了二叉堆的数据结构，我们知道二叉堆结构中的根元素是最大（或者最小）的元素。并且学习了**堆的有序化**方式，一种是删除第一个元素，然后使用**下沉**的方式使堆有序化；另一种是在末尾添加元素，然后使其**上浮**至正确的位置。

既然堆每次有序化之后都能得出一个最大（或者最小）的元素，那么我们是不是可以把最大（或者最小）的元素取出来，然后把剩下的元素堆有序再取出一个最大（或者最小）的元素，直至剩下最后一个元素，是不是就可以实现排序了？

这种每次都找出最大（或者最小）的元素的方式跟选择排序有点类似，只不过堆的数据结构可以让我们更快地找出那个最大（或者最小）的元素，这种排序方法就叫做**堆排序**。

## 如何实现堆排序？

给定一个数组，我们如何实现堆排序？很显然，我们首先要做的就是先将这个数组看做二叉堆，然后将其堆有序我们才能获取到第一个最大
（此处不讨论最小）的元素。所以，我们首要解决的问题就是：**如何将一个给定的数组堆有序？**。

- 方法一：通过[优先队列](http://rason.me/2016/07/06/PriorityQueue/)这篇文章的学习，我们不难想到：将数组中的元素从左到右遍历插入到优先队列中，队列中的数组就是堆有序了。**即从左到右遍历，使用swim()方法将其堆有序**。

- 方法二：通过上面的方式当然可以实现堆有序，然而需要遍历整个数组效率就比较低了，如果通过sink()方式就更高效了，因为它无需遍历整个数组即可实现堆有序。举个例子：

![使用下沉（sink）的方式无需遍历整个数组](https://raw.githubusercontent.com/rason/rason.github.io/master/image/HeapSort1)

如上图所示，我们依次对位置5，4，3，2，1的元素依次调用sink（）方法是不是就可以将数组堆有序了？

因此，**使用sink()方法将数组堆有序只需遍历一半的数组**，代码如下：

```
int N = a.length;
for (int k = N/2; k > 0; k--) {
	sink(a, k, N);
}
```

这里的sink（）在[优先队列](http://rason.me/2016/07/06/PriorityQueue/)一文中已经提及过，只是将方法中需要用到的变量作为参数传入其中。

<!-- more -->

现在，我们已经将数组堆有序了，剩下的问题就简单了。只要我们将第一个元素（即最大元素）和最后一个元素交换位置，这是最后一个位置的元素是不是就是最大的元素？位置是不是就确定了？然后使用sink()方法将第一个元素下沉至正确的位置，然后再取第一个元素和最后一个元素交换位置（注意此时总元素已经减少了一个，相当于原来倒数第二个元素）；再使用sink()方法将第一个元素下沉至正确的位置，依次类推；剩下最后一个元素时，排序完成。

文字说的有点复杂，其实就三行代码，如下所示：

```
while(N > 1){
	exch(a, 1, N--);
	sink(a, 1, N);
}
```

所以，堆排序的完整代码如下所示：

```
package com.rason.algs4.sort;

public class HeapSort extends Sort {

	@Override
	void sort(Comparable[] a) {
		int N = a.length;
		for (int k = N/2; k > 0; k--) {
			sink(a, k, N);
		}
		
		while(N > 1){
			exch(a, 1, N--);
			sink(a, 1, N);
		}
	}

	private void sink(Comparable[] a, int k, int N){
		while( 2*k <= N){
			int j = 2*k;
			if(j < N && less(a[j], a[j+1]))
				j++;
			if(!less(a[k], a[j]))
				break;
			exch(a, k, j);
			k = j;
		}
	}
	
	public static void main(String[] args){
		HeapSort heapSort = new HeapSort();
		Integer[] a = {3,1,4,7,5,8,6};
		heapSort.sort(a);
		heapSort.show(a);
	}
}

```
运行上面的代码，其实是会有报错的，数组出现越界，因为我们的下沉操作方法没有用到数组索引为0的位置，这就当做改造作业让大家思考吧。

## 堆排序的性能

**首先，我们来思考一下将数组堆有序需要多少次比较和多少次交换。**

如上面二叉树图中的5,10,11结点，可以看成一个大小为3的堆，将5结点下沉最差需要一次交换，两次比较；4,8,9结点类似。

将2,4,5,8,9,10,11看成大小为7的堆，将结点2下沉最差需要两次交换，四次比较；

大小为15的堆，需要三次交换，六次比较；

给出结论：**用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换**。

证明：比如要构造一个127个元素的堆，我们会处理32个大小为3的堆，16个大小为7的堆，8个大小为15的堆，4个大小为31的堆，2个大小为63的堆和1个大小为127的堆。因此最坏情况需要32*1+16*2+8*3+4*4+2*5+1*6=120次交换（比较是交换的两倍）。

**然后，就是思考将堆有序后的数组排序需要多少次比较和多少次交换了。**

根据上一篇文章中的结论，每次下沉操作最大可能需要2lgN次比较，所以N个元素下沉排序需要2NlgN次比较。

因此，**N个元素堆排序总共需要少于（2N+2NlgN）次比较（以及一半次数的交换）**。

## 总结

本文主要讲述了如何利用二叉堆这种数据结构实现堆排序，首先要对数组进行堆有序，然后再依次取出最大元素放到后面来实现，关键是懂得上一篇文章中的下沉操作，理解起来就不难了。


