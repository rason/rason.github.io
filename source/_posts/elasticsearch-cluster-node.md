---
title: Elasticsearch节点
date: 2017-08-28 15:56:39
categories: BigData
tags: Elasticsearch
description: Elasticsearch节点
---

当我们启动一个Elasticsearch实例时，就是在启动一个节点。一系列连接在一起的节点就称为一个集群。如果你运行单一节点的Elasticsearch ，那么你就拥有了一个只有一个节点的集群。

默认情况下，群集中的每个节点都可以处理HTTP请求和传输通信。 传输层专用于节点和Java TransportClient之间的通信; HTTP层仅由外部REST客户端使用。

所有节点都知道集群中其它节点的情况并且可以转发客户端请求到适当的节点。除此之外，每个节点都可以充当一个或者角色：

- **主节点**
	
	节点的node.master属性被设置为true(默认),使得它有资格被选举为主节点，用于控制集群。

- **数据节点**

	节点的node.data属性被设置为true(默认)。数据节点持有数据并处理数据相关的操作，比如CRUD，搜索和聚合。

- **Ingest节点**

	节点的node.ingest属性被设置为true(默认)。可以采用流水线的方式对索引的文档进行加工处理。这个节点的负载会比较大，使用专用的节点作为Ingest，并且将主节点和数据节点的node.ingest属性设置为false是一个很好的方式。

- **Tribe节点**

	通过`tribe.*`配置，是一种仅用于协调的特殊节点。可以连接到多个集群，并在所有连接的集群中执行搜索和其他操作。

默认情况下，一个节点是不仅是具有主资格的节点，还是数据节点，外加可以通过Ingest流水线对文档进行预处理。这对于一个小集群来说非常方便，但是随着集群的增长，将主节点和数据节点单独分开会变得越来越重要。

> **协调节点**

> 请求(比如搜索请求或者批量索引请求)可能会包含位于不同节点的数据.例如，一个搜索请求，由接收客户端请求的节点协调分两个阶段执行——这个节点就是协调节点。

> 分散阶段，协调节点将请求转发到保存数据的数据节点。每个数据节点本地执行请求然后返回结果到协调节点。在聚集阶段，协调节点将每个数据节点的结果聚合为一个全局的结果集。

> 每个节点都隐式作为协调节点。这意味这如果一个节点的node.master,node.data,node.ingest三个属性都设为false，那么它就只能作为一个协调节点，协调功能是没法禁用的。这样的一个节点需要有足够的内存和CPU才能处理聚合阶段。

<!-- more -->

## 主节点

主节点负责轻量级的集群范围的操作，例如创建或删除索引，跟踪哪些节点是集群的一部分，以及决定哪些分片分配给哪些节点。 拥有稳定的主节点对集群健康很重要。

任何具有主控资格的节点(默认都有)都可能被选举为主节点。

> 主节点必须可以访问`data/`目录(跟数据节点一样)，因为这里保存这集群的状态信息。

索引和搜索数据是CPU,内存和IO密集型的工作，这会增加节点资源的压力。为了确保主节点不要承受太大的压力，在一个大的集群中将主控资格的节点和数据节点角色独立分开会比较好。

虽然主节点也可以作为协调节点，并将搜索和索引请求从客户端路由到数据节点，但最好不要为此目的使用专用主节点。具有主控资格的节点做的事情越少，对于集群的稳定性就越好。

创建一个专用的主控资格节点：

```
node.master: true 
node.data: false 
node.ingest: false 
```

> 这些设置只有在X-Pack 没有安装的情况下生效。

### 通过`minimum_master_nodes`避免分裂的集群

为了避免数据的丢失，配置`discovery.zen.minimum_master_nodes`属性(默认为１)至关重要，以便每个具有主控资格的节点知道至少需要多少个具有主控资格的节点才能形成一个集群。

想象一下由两个具有主控资格的节点组成的集群。假设这两个节点之间的通信失败，每个节点只能看到一个具有主控资格的节点，就是其自己。因为`minimum_master_nodes`默认设置为１，所以只有一个主控资格的节点也能形成集群，这样的话两个节点都选举自己为新的主节点(因为它们都认为对方挂掉了)，结果就导致了两个集群，即集群分裂。这两个节点永远不会重新联合在一起，直到重新启动一个节点。 已经写入重新启动的节点的任何数据都将丢失。

现在假设我们有一个具有三个主控资格的节点组成的集群，并且`minimum_master_nodes`设置为2。如果一个节点与其他两个节点的通信失败，这个节点看到没有足够具有主控资格的节点来形成一个集群，所以不能选举自己为主节点。而另外两个节点能够通信，看到足够具有主控资格的节点，所以它们之间可以选举出一个新的主节点并正常工作。一旦网络通信问题修复，通信失败的那个节点会重新加入集群并开始处理请求。

`minimum_master_nodes`应设置为：

```
(master_eligible_nodes / 2) + 1
```

也就是说，假如有三个具有主控资格的节点，那么最少主节点应该设置为`(3/2) + 1`或者`2`:

```
discovery.zen.minimum_master_nodes: 2
```

也可以通过API动态设置：

```
PUT _cluster/settings
{
  "transient": {
    "discovery.zen.minimum_master_nodes": 2
  }
}
```

## 数据节点

数据节点持有分片，分片中包含已经索引的文档。数据节点处理数据相关的操作，比如CRUD，搜索和聚合。这些操作都是IO，内存和CPU密集型的。所以要实时监控这些节点的资源是否过载，如果过载了就要添加更多的节点。

创建一个专用的数据节点：

```
node.master: false 
node.data: true 
node.ingest: false
```

## Ingest节点

Ingest节点可以执行由一个或者多个Ingest处理器组成的预处理流水线。根据Ingest处理器执行的操作类型和所需的资源，具有专门的Ingest节点来执行特定的任务可能是有意义的。

创建一个专用的Ingest节点：

```
node.master: false 
node.data: false 
node.ingest: true 
search.remote.connect: false
```

## 只协调节点

如果我们将节点的主控资格，保存处理数据和预处理文档这几个功能拿掉，那么就只剩下路由请求，处理搜索聚合节点和分发批量索引请求这些功能了，这就是一个只具有协调功能节点。本质上，只协调节点就是一个小型的负载均很器。

在大型集群中，将协调节点角色从数据节点和具有主控资格的节点分离开来形成一个只协调节点还是有意义的。它们加入集群并接收全部的集群状态信息，跟其他节点一样，使用集群状态信息来路由请求到适当的地方。

> 添加过多的只协调节点会增加整个集群的压力，因为选举主节点必须等待来自每个节点的群集状态更新的确认。只协调节点的作用也不能被夸大——因为数据节点也乐意做同样的工作。

创建一个专用的协调节点：

```
node.master: false 
node.data: false 
node.ingest: false 
search.remote.connect: false
```
