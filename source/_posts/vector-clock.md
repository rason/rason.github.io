---
title: 向量时钟
date: 2017-09-20 08:43:03
categories: Distributed
tags: Consensus
description: vector clock
---

在分布式系统中，每台机器都有个物理时钟。但是由于每台机器的时钟频率总会有一点偏差，当时间长了，物理时钟偏差就会越来越大。有机械手表的同学应该会相当的理解，我的手表就是每个月会偏差一两分钟。当然，计算机的时钟不会偏差那么大。

当时间发生了偏差，那么就出现问题了，在分布式系统中如果有两个事件发生在不同的机器上，而且时间靠的非常的近，这样我们就有可能无法确定哪件事情先发生。出现这样的问题，我们首先能想到的解决办法就是找到一个极度标准的时钟，然后按固定频率去同步这个时钟。这就好像我的机械手机，我每个月月初都会将其调整到和互联网时间一致。然而，这种方法显然是无法做到绝对的精确。**向量时钟**就是为了解决这类型的问题而出现。

## 向量时钟

> 向量时钟是在分布式系统中生成事件的偏序并检测因果关系的一种算法。就好像[Lamport timestamps](https://en.wikipedia.org/wiki/Lamport_timestamps)一样，在进程间消息包含发送进程的[逻辑时钟](https://en.wikipedia.org/wiki/Logical_clock)状态。

N个进程的向量时钟就是一个大小为N的逻辑时钟数组，并遵循以下更新规则：

- 初始时钟都为0.
- 每当进程发生一件内部事件时，需要在向量时钟中增加自己的逻辑时钟.
- 每当进程发送一个消息，需要增加自己的逻辑时钟，然后将整个向量时钟和信息一起发送出去.
- 每当进程接收一个消息，需要增加自己的逻辑时钟，然后将自己的向量时钟和接收到信息的向量时钟合并，取向量时钟对应位置的最大值更新自己的向量时钟.

举个例子，假设分布式系统中有三个进程，某个时刻进程p1的向量时钟是[1,2,3]，接收到消息m（假设其附带的向量时钟是[0,4,2]）后。根据最后一条规则，进程p1将自己向量时钟对应位置加1，此时p1的向量时钟为[2,2,3]，然后和接收到消息的向量时钟的对应位置对比取最大值，进程p1会将自己的向量时钟更新为[2,4,3].

## 因果关系

> 如果事件E的向量时钟各个维度都小于等于事件F对应位置的数值且至少有一位是小于，那么可以称为事件E是事件F的原因，事件F是事件E的结果。这里的原因和结果指的是两者之间是否有逻辑上的因果影响关系。

如果两个事件没有因果影响关系，有可能是产生了冲突。

## Amazon Dynamo 

Amazon Dynamo KV存储系统中使用了向量时钟解决数据一致性问题。假设有三份数据副本，保存在不同的机器上，将这三个副本命名为n1,n2,n3。

假设，n1、n2、n3要存储的用户id为1的用户的昵称。
最开始，三个副本的向量时钟以及数据如下表示：

```
n1: { vector: {n1:0, n2:0, n3:0}, data: null }
n2: { vector: {n1:0, n2:0, n3:0}, data: null }
n3: { vector: {n1:0, n2:0, n3:0}, data: null }
```

时刻1，n1将用户昵称更新为jian，向量时钟以及数据更新后如下：

```
n1: { vector: {n1:1, n2:0, n3:0}, data: 'jian' }
n2: { vector: {n1:0, n2:0, n3:0}, data: null }
n3: { vector: {n1:0, n2:0, n3:0}, data: null }
```

然后n1给n2、n3发送消息同步数据，更新后如下：

```
n1: { vector: {n1:2, n2:0, n3:0}, data: 'jian' }
n2: { vector: {n1:2, n2:1, n3:0}, data: 'jian' }
n3: { vector: {n1:2, n2:0, n3:1}, data: 'jian' }
```

此时对系统进行读操作，结果应是’jian’。

时刻2，n3将用户昵称改为’fan’，更新后如下：

```
n1: { vector: {n1:2, n2:0, n3:0}, data: 'jian' }
n2: { vector: {n1:2, n2:1, n3:0}, data: 'jian' }
n3: { vector: {n1:2, n2:0, n3:2}, data: 'fan' }
```

此时对系统进行读操作，结果应是’fan’。n3先给n2发送了消息，更新后如下：

```
n1: { vector: {n1:2, n2:0, n3:0}, data: 'jian' }
n2: { vector: {n1:2, n2:2, n3:3}, data: 'fan' }
n3: { vector: {n1:2, n2:0, n3:3}, data: 'fan' }
```

当n3要给n1发消息之前，n1却对数据进行了修改，例如将用户昵称改为’ ruan’，更新后如下：

```
n1: { vector: {n1:3, n2:0, n3:0}, data: 'ruan' }
n2: { vector: {n1:2, n2:2, n3:3}, data: 'fan' }
n3: { vector: {n1:2, n2:0, n3:3}, data: 'fan' }
```

此时观察n1和n3的向量时钟没有因果关系，数据发生了冲突，Dynamo的设计思路是让客户端自己去解决这种冲突。

