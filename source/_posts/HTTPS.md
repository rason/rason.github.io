---
title: HTTPS 的思考
date: 2019-06-25 10:49:05
tags:
---

众所周知, HTTPS 是为了解决信息安全传输的问题, 我们来推理一下, 怎么才能达到安全传输的效果.

比如, A 发信息和 B 聊天, 为了防止聊天内容被截获偷窥, 我们可以怎么做?

### 对称加密

一个比较简单的方式, 就是对聊天内容进行加密, A 发送消息前用密码 XXX 对内容进行加密, B 收到之后对内容用密码 XXX 进行解密, 这种方式称为对称加密. 其他人不知道密码, 当然就没法对内容进行解密.

但是, A 怎么把密码告诉 B 呢, 如果通过网络传输, 发送的密码被偷窥了, 那也没办法达到安全传输. 当然, A 可以通过线下的方式将密码给到 B, 可是 A 还要跟很多人聊天, 不可能都通过线下的方式.


### 非对称加密

为了解决对称加密的存在的问题, 出现了非对称加密. A 和 B 都有一对公私秘钥对, A 公钥加密的内容只有 A 的私钥才能解密, B 公钥加密的内容只有 B 的私钥才能解密. 这样, A 把自己的公钥给 B, B 把自己的公钥给 A. 聊天的时候:

`A 发送的内容 ---> 用 B 的公钥加密 ---> B 接收到加密的内容 ---> B 用自己的私钥解密`

这样就能达到安全传输了, 因为 B 的私钥只有自己才有, B 的公钥泄漏了也没关系, 公钥是用来加密的. 

### 非对称加密 + 对称加密

非对称加密一般比较慢, 如果内容一直都是用对称加密来保护, 那性能就会有影响了. 所以, 我们可以用对称加密的方式来传输对称加密的密钥, 之后就用对称加密来聊天即可.

### 中间人夹击

但是, 非对称加密也没法解决**中间人夹击**的问题.

试想一下, 在 A 和 B 之间, 有一个中间人. 在 A 和 B 交互公钥的时候, 中间人都把公钥拦截下来了, 把自己的公钥给到 A 和 B. 这样, A 以为自己在和 B 聊天, 其实是在和中间人聊天, B 也一样.

`A 发送的内容 ---> 用中间人的公钥加密 ---> 中间人接收到加密的内容 ---> 中间人用自己的私钥解密, 偷看到内容了 ---> 中间人用 B 的公钥加密 ---> B 接收到加密的内容 ---> B 用自己的私钥解密`

### 公钥究竟是谁的?

中间人夹击的问题在于公钥被偷天换日了, A 收到的公钥怎么才能知道这确确实实是 B 的公钥, 而不是中间人的?

现实中, 我们用身份证来表明自己的身份. 那么, 网络中有没有一个公信力的机构, 给 A 和 B 颁发一个"身份证", 这个"身份证"上有属于自己的公钥. 当 A 拿到 B 的"身份证"的时候, 一看是 B 的, 然后从中拿到公钥.

这里的"身份证"就是数字证书, 而公信力机构就是 CA.

但是, 我怎么知道这个"身份证"是真的还是假的呢? 国家的身份证系统能查到身份证的真假, 那么操作系统或浏览器其实也有预置的CA列表来验证这个"身份证"是不是伪造的.

### HTTPS 简化流程

1. 浏览器发出 HTTPS 请求
2. 服务器发送数字证书(证书上有服务器的公钥)
3. 浏览器用预置的CA列表来验证证书是不是伪造的, 如果有风险则提示
4. 浏览器生成随机的密钥对, 用服务器的公钥加密发送自己的密钥对给服务器
5. 服务器用自己的私钥解密, 得到浏览器的密钥对
6. 双方都知道了公钥, 可以开始加密传输了


