title: 进程和线程
categories: OS
date: 2016-09-22 10:35:00
tags: 进程和线程
description: 进程和线程
---

## 前言

自己对进程和线程的了解其实不是很深入，只是大概知道计算机通过CPU时间片切换实现多进程，一个进程中可以有多个线程。今天，让我们更进一步了了解进程和线程的知识。

## 进程

在多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百个毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程。但在1秒钟期间，它可能运行多个进程，这样就产生并行的错觉。操作系统的设计者用进程模型来描述并行，使得并行更容易处理。

### 进程模型

在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干**顺序进程**，简称**进程**。一个进程就是一个**正在执行程序的实例**，包括程序计算器、寄存器和变量的当前值。

### 进程的状态

进程具有三种状态：

- **运行态**：该时刻进程实际占用CPU。
- **就绪态**：可运行，但因为其他进程正在运行而暂时停止。
- **阻塞态**：除非某种外部事件发生，否则进程不能运行。

进程的三种状态之间有四种可能的转换关系，如下图：

![进程三种状态的转换](https://raw.githubusercontent.com/rason/rason.github.io/master/image/process-status)

转换1和2是由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。**调度程序**的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间。我们可以想象系统的内部模型如下图：

<!-- more -->

![以进程构造的操作系统最底层处理中断和调度，在该层之上是顺序进程](https://raw.githubusercontent.com/rason/rason.github.io/master/image/process-dispatcher)

操作系统的最底层是调度程序，在它上面有许多进程。所有关于中断处理、启动进程、停止进程的具体细节都隐藏在调度程序中。操作系统的其他部分被简单地组织成进程的形式。不过，很少有真实的系统是以这样的理想方式构造。

### 进程的实现

操作系统维护着一张表格（一个结构数组），即**进程表**。每个进程占用一个进程表项（也称进程控制块）。该表项包含进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他进程由运行态换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。

下图中展示一个典型系统中的关键字段：

![典型的进程表表项中的一些字段](https://raw.githubusercontent.com/rason/rason.github.io/master/image/process-message)

## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上，这几乎就是进程的定义。不过，经常存在在同一地址空间中并行运行多个控制线程的情况，这些线程就像分离的进程（共享地址空间除外）。

### 线程的使用

为什么需要线程？

- 在许多应用中同时发生这多种活动，比如我们在编译一个文件时，还有一个后台线程在不断地自动保存
- 线程比进程更加轻量级，比进程更容易创建和撤销
- 性能方面考虑，若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/O处理，性能就会得以提升

举一个多线程的例子：Web服务器。如下图所示：

![一个多线程的Web服务器](https://raw.githubusercontent.com/rason/rason.github.io/master/image/muti-thread-ws)

上图中，一个称为**分派程序**的线程从网络中读入工作请求。在检查请求之后，分派线程挑选一个空转的(即被阻塞的)**工作线程**，提交该请求。接着分派线程唤醒睡眠的工作线程，将它从阻塞状态转为就绪状态。

在工作线程被唤醒后，它检查有关的请求是否在Web页面高速缓存之中。如果没有，该线程开始从磁盘调入页面的read操作，并且阻塞到该磁盘操作完成。当上述线程阻塞在磁盘操作上时，为了完成更多的工作，分派线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。

### 线程模型

进程模型基于两种独立的概念：**资源分组处理**与**执行**。将这两种概念分开也就引入了线程概念。

理解进程的一个角度是，用某种方法把**相关的资源集中在一起**。进程有存放程序正文和数据以及其他资源的地址空间。

另一个角度是，**进程拥有一个执行的线程**，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈用来记录执行历史。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。**进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体**。

线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。**在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟**。只不过，**多个线程共享同一个地址空间和其他资源**,而多个进程共享物理内存、磁盘、打印机和其他资源。

多道程序设计中，通过多个进程之间来回切换制造并行运行的假象。多线程的工作方式也是类似的，CPU在多个线程之间切换，制造线程并行运行的假象。

![三个进程，每个进程有一个线程](https://raw.githubusercontent.com/rason/rason.github.io/master/image/muti-process)

![一个进程带三个线程](https://raw.githubusercontent.com/rason/rason.github.io/master/image/muti-thread)

进程中不同线程不像不同进程之间那样存在很大的独立性。**所有的线程都有完全一样的地址空间，这意味这它们也共享同样的全局变量**。这就是我们平时多线程编程中需要注意的问题了。

![第一列给出了在一个进程中所有线程共享的内容，第二列给出了每个线程自己的内容](https://raw.githubusercontent.com/rason/rason.github.io/master/image/process-thread-msg)

和传统进程一样（即只有一个线程的进程），线程可以处理若干种状态的任何一个：运行、阻塞、就绪或终止。线程状态之间的转换和进程状态之间的转换是一样的。

## 总结

本文首先学习了进程的模型，进程用于描述一个正在执行程序的实例，进程是相关资源的集合，系统用进程表来维护进程的资源信息。从进程的模型引出了线程模型，进程由资源和一个执行线程组成，将这两个概念分开就引出了多线程。同一进程的多个线程是共享地址空间的，而进程都有自己的独立地址空间。
