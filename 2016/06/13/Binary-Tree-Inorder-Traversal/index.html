<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="二叉树中序遍历">


<link rel="alternate" href="/atom.xml" title="Rason&#39;s Blog" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>二叉树中序遍历 - Rason&#39;s Blog</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">
<link rel="stylesheet" href="/css/style.css">
<nav class="main-nav">
	
	    <a href="/">← Home</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
</nav>


<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>二叉树中序遍历</h1>
        
        <h2 class="headline">Jun 13 2016
        
            
            <a href="/categories/LeetCode/#LeetCode">LeetCode</a>
        
        </h2>
    </header>
</article>
<section id="post-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然的知道了LeetCode，正好自己也在学习算法，于是上去随机选了一道题来做——二叉树的终须遍历。咋一看题目，由于太久没复习算法和数据结构，连二叉树的概念都模糊了，更别说中序遍历了。于是，先谷歌了一下概念，然后设法遍历……</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote>
<p>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">   int val;</span><br><span class="line">   TreeNode left;</span><br><span class="line">   TreeNode right;</span><br><span class="line">   TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>前序遍历：根节点，左子树，右子树</li>
<li>中序遍历：左子树，根节点，右子树</li>
<li>后序遍历：左子树，右子树，根节点</li>
</ul>
<p><strong>注意：</strong>这里要理解的是树，而不是孩子。举个例子：</p>
<p><img src="/image/binaryTree" alt="二叉树"></p>
<a id="more"></a>
<p>上图中，根节点为1，{2,4,5，8}为左子树，{3,6,7,9,10}为右子树；再深入1的左子树，它也是一棵二叉树，根节点为2，左子树为{4}，右子树为{5、8}；依此类推。</p>
<p>因此，上图中的各种遍历结果如下：</p>
<ul>
<li>前序遍历：1 2 4 5 8 3 6 7 9 10</li>
<li>中序遍历：4 2 8 5 1 6 3 9 7 10</li>
<li>后序遍历：4 8 5 2 6 9 10 7 3 1</li>
</ul>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>好了，简单地复习完上述概念，可以开始着手编写代码实现中序遍历了。LeetCode给出的代码模板如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求很简单，就是给出一个根节点，返回中序遍历的节点值。先不要往下看答案，先自己想一下怎么实现。</p>
<p>…<br>…<br>…</p>
<p>由于本人智商比较拙计，看着上面那张图想了大半天没想出来怎么做。其中想过用栈的方式，但是想不出一个栈怎么整；其中又想了多个栈能不能实现，稀里糊涂地折腾了半天楞是没想出来。</p>
<p>…<br>…<br>…</p>
<p>后来，我干脆放弃上面那张图了，我为什么要按照上面那张那么复杂的图来想，我不会按照只有三个节点的二叉树的图来实现吗？这不就简单多了吗？</p>
<p><img src="/image/binaryTree2" alt="简单的二叉树"></p>
<p>嘿嘿，我真的是太机智了，遍历上面只有三个节点的二叉树难道我不会？然后就吭哧吭哧的开始编码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	public static List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printNode(TreeNode root)&#123;</span><br><span class="line">		System.out.println(root.left.val);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		System.out.println(root.right.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单地，我干脆就先直接把它们打印出来，先不返回遍历之后的数组，打印成功了就证明我遍历成功啦。嘿嘿，有了上面的基础，然后我就想，左子树也是一棵树呢，那是不是也可以这样打印？同理，右子树应该也是一样的啊。于是，我就想到了递归的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	public static List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printNode(TreeNode root)&#123;</span><br><span class="line">		if(root.left != null)</span><br><span class="line">			printNode(root.left,list);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		if(root.right != null)</span><br><span class="line">			printNode(root.right,list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	TreeNode one = new TreeNode(1);</span><br><span class="line">	TreeNode two = new TreeNode(2);</span><br><span class="line">	TreeNode three = new TreeNode(3);</span><br><span class="line">	TreeNode four = new TreeNode(4);</span><br><span class="line">	TreeNode five = new TreeNode(5);</span><br><span class="line">	TreeNode six = new TreeNode(6);</span><br><span class="line">	TreeNode seven = new TreeNode(7);</span><br><span class="line">	TreeNode eight = new TreeNode(8);</span><br><span class="line">	TreeNode nine = new TreeNode(9);</span><br><span class="line">	TreeNode ten = new TreeNode(10);</span><br><span class="line">	</span><br><span class="line">	one.left = two;</span><br><span class="line">	one.right = three;</span><br><span class="line">	</span><br><span class="line">	two.left = four;</span><br><span class="line">	two.right = five;</span><br><span class="line">	</span><br><span class="line">	three.left = six;</span><br><span class="line">	three.right = seven;</span><br><span class="line">	</span><br><span class="line">	five.left = eight;</span><br><span class="line">	</span><br><span class="line">	seven.left = nine;</span><br><span class="line">	seven.right = ten;</span><br><span class="line">	</span><br><span class="line">	printNode(one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现输入结果和上面描述的中序排序结果一样，成功了！</p>
<p>既然已经成功地打印了中序遍历，那么只需要将程序简单地改造一下就可以返回中序遍历的数组了。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		printNode(root, result);</span><br><span class="line">		return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	public void printNode(TreeNode root,List&lt;Integer&gt; list)&#123;</span><br><span class="line">	    if (root == null)</span><br><span class="line">			return;</span><br><span class="line">		if(root.left != null)</span><br><span class="line">			printNode(root.left,list);</span><br><span class="line">		list.add(root.val);</span><br><span class="line">		if(root.right != null)</span><br><span class="line">			printNode(root.right,list);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题在LeetCode上的困难程度属于中等，由于太久时间没有温习数据结构和算法，所以思考了很久才想出解决方案。值得高兴的是，通过自己的思考找到了解决的方法，并且通过将问题化繁为简得出了解决问题的思路，这将成为一套自己的方法论。<strong>遇到问题不要胡思乱想，先将问题简单化，或者先将问题特殊化，找出解决方案，然后在此基础上进行解决方案的一般化。</strong></p>
<p>另外，在提交自己的答案之后，看了一些别人的答案。还真有人用栈的方式来实现，十分巧妙，也证明了自己当时的思考思路并没有完全错，而是没有将问题简单化思考，从而导致了半天没思考出来。这里贴一下别人的巧妙解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    while(cur!=null || !stack.empty())&#123;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            stack.add(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法很巧妙地控制了入栈和出栈的时机，实现遍历。当初自己就是一条筋想把所有元素全部压入栈再遍历出来，怎么就没想到又压又出。</p>
</section>
    
        
        <h2 class="footline">
            <a href="/tags/Binary-Tree/#Binary Tree">Binary Tree</a>
        </h2>
    

    <footer id="post-meta" class="clearfix">
        <a href="/about/">
        <img class="avatar" src="/images/avatar.png">
        <div>
            <span class="dark">Rason&#39;s Blog</span>
            <span></span>
        </div>
        </a>
        <section id="sharing">
            <a title="Share to Twitter" class="twitter" href="https://twitter.com/intent/tweet?text=http://ideajava.com/2016/06/13/Binary-Tree-Inorder-Traversal/ - 二叉树中序遍历 @"><span class="icon-twitter">tweet</span></a>
            <a title="Share to Facebook" class="facebook" href="#" onclick="
                window.open(
                  'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
                  'facebook-share-dialog',
                  'width=626,height=436');
                return false;"><span class="icon-facebook-sign">Share</span>
            </a>
        </section>
    </footer>


	<footer id="footer">
	<div id="social">
		<p class="small">©  rason| Powered by Hexo 
	
	<a href="http://www.beian.miit.gov.cn" target="_blank">粤ICP备17046371号-1</a></p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant=""></script>
	<script data-no-instant="">
		
		InstantClick.init('mousedown');
	</script>



