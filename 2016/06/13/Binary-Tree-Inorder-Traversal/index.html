<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        二叉树中序遍历
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/spring.png">
        </div>
        <div class="name">
            <i>rason</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
<!--            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
    -->        <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中序遍历"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        二叉树中序遍历
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2016-06-13 10:00:35</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Binary Tree" title="Binary Tree">Binary Tree</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然的知道了LeetCode，正好自己也在学习算法，于是上去随机选了一道题来做——二叉树的终须遍历。咋一看题目，由于太久没复习算法和数据结构，连二叉树的概念都模糊了，更别说中序遍历了。于是，先谷歌了一下概念，然后设法遍历……</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote>
<p>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">   int val;</span><br><span class="line">   TreeNode left;</span><br><span class="line">   TreeNode right;</span><br><span class="line">   TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul>
<li>前序遍历：根节点，左子树，右子树</li>
<li>中序遍历：左子树，根节点，右子树</li>
<li>后序遍历：左子树，右子树，根节点</li>
</ul>
<p><strong>注意：</strong>这里要理解的是树，而不是孩子。举个例子：</p>
<p><img src="https://raw.githubusercontent.com/rason/rason.github.io/master/image/binaryTree" alt="二叉树"></p>
<a id="more"></a>
<p>上图中，根节点为1，{2,4,5，8}为左子树，{3,6,7,9,10}为右子树；再深入1的左子树，它也是一棵二叉树，根节点为2，左子树为{4}，右子树为{5、8}；依此类推。</p>
<p>因此，上图中的各种遍历结果如下：</p>
<ul>
<li>前序遍历：1 2 4 5 8 3 6 7 9 10</li>
<li>中序遍历：4 2 8 5 1 6 3 9 7 10</li>
<li>后序遍历：4 8 5 2 6 9 10 7 3 1</li>
</ul>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>好了，简单地复习完上述概念，可以开始着手编写代码实现中序遍历了。LeetCode给出的代码模板如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求很简单，就是给出一个根节点，返回中序遍历的节点值。先不要往下看答案，先自己想一下怎么实现。</p>
<p>…<br>…<br>…</p>
<p>由于本人智商比较拙计，看着上面那张图想了大半天没想出来怎么做。其中想过用栈的方式，但是想不出一个栈怎么整；其中又想了多个栈能不能实现，稀里糊涂地折腾了半天楞是没想出来。</p>
<p>…<br>…<br>…</p>
<p>后来，我干脆放弃上面那张图了，我为什么要按照上面那张那么复杂的图来想，我不会按照只有三个节点的二叉树的图来实现吗？这不就简单多了吗？</p>
<p><img src="https://raw.githubusercontent.com/rason/rason.github.io/master/image/binaryTree2" alt="简单的二叉树"></p>
<p>嘿嘿，我真的是太机智了，遍历上面只有三个节点的二叉树难道我不会？然后就吭哧吭哧的开始编码了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	public static List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printNode(TreeNode root)&#123;</span><br><span class="line">		System.out.println(root.left.val);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		System.out.println(root.right.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单地，我干脆就先直接把它们打印出来，先不返回遍历之后的数组，打印成功了就证明我遍历成功啦。嘿嘿，有了上面的基础，然后我就想，左子树也是一棵树呢，那是不是也可以这样打印？同理，右子树应该也是一样的啊。于是，我就想到了递归的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	public static List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printNode(TreeNode root)&#123;</span><br><span class="line">		if(root.left != null)</span><br><span class="line">			printNode(root.left,list);</span><br><span class="line">		System.out.println(root.val);</span><br><span class="line">		if(root.right != null)</span><br><span class="line">			printNode(root.right,list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	TreeNode one = new TreeNode(1);</span><br><span class="line">	TreeNode two = new TreeNode(2);</span><br><span class="line">	TreeNode three = new TreeNode(3);</span><br><span class="line">	TreeNode four = new TreeNode(4);</span><br><span class="line">	TreeNode five = new TreeNode(5);</span><br><span class="line">	TreeNode six = new TreeNode(6);</span><br><span class="line">	TreeNode seven = new TreeNode(7);</span><br><span class="line">	TreeNode eight = new TreeNode(8);</span><br><span class="line">	TreeNode nine = new TreeNode(9);</span><br><span class="line">	TreeNode ten = new TreeNode(10);</span><br><span class="line">	</span><br><span class="line">	one.left = two;</span><br><span class="line">	one.right = three;</span><br><span class="line">	</span><br><span class="line">	two.left = four;</span><br><span class="line">	two.right = five;</span><br><span class="line">	</span><br><span class="line">	three.left = six;</span><br><span class="line">	three.right = seven;</span><br><span class="line">	</span><br><span class="line">	five.left = eight;</span><br><span class="line">	</span><br><span class="line">	seven.left = nine;</span><br><span class="line">	seven.right = ten;</span><br><span class="line">	</span><br><span class="line">	printNode(one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现输入结果和上面描述的中序排序结果一样，成功了！</p>
<p>既然已经成功地打印了中序遍历，那么只需要将程序简单地改造一下就可以返回中序遍历的数组了。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		printNode(root, result);</span><br><span class="line">		return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	public void printNode(TreeNode root,List&lt;Integer&gt; list)&#123;</span><br><span class="line">	    if (root == null)</span><br><span class="line">			return;</span><br><span class="line">		if(root.left != null)</span><br><span class="line">			printNode(root.left,list);</span><br><span class="line">		list.add(root.val);</span><br><span class="line">		if(root.right != null)</span><br><span class="line">			printNode(root.right,list);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题在LeetCode上的困难程度属于中等，由于太久时间没有温习数据结构和算法，所以思考了很久才想出解决方案。值得高兴的是，通过自己的思考找到了解决的方法，并且通过将问题化繁为简得出了解决问题的思路，这将成为一套自己的方法论。<strong>遇到问题不要胡思乱想，先将问题简单化，或者先将问题特殊化，找出解决方案，然后在此基础上进行解决方案的一般化。</strong></p>
<p>另外，在提交自己的答案之后，看了一些别人的答案。还真有人用栈的方式来实现，十分巧妙，也证明了自己当时的思考思路并没有完全错，而是没有将问题简单化思考，从而导致了半天没思考出来。这里贴一下别人的巧妙解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    while(cur!=null || !stack.empty())&#123;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            stack.add(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法很巧妙地控制了入栈和出栈的时机，实现遍历。当初自己就是一条筋想把所有元素全部压入栈再遍历出来，怎么就没想到又压又出。</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
<!--        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
    Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a>-->
 <a href="http://www.beian.miit.gov.cn">粤ICP备17046371号-1</a>  
</p> 
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
