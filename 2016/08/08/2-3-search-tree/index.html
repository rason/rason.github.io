<!DOCTYPE html>

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=0">

  <meta name="description" content="2-3 search tree">


<link rel="alternate" href="/atom.xml" title="Rason&#39;s Blog" type="application/atom+xml">
<meta name="theme-color" content="#a1d0f6">
<title>2-3查找树 - Rason&#39;s Blog</title>
<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<link rel="shortcut icon" href="/favicon.png">
<link rel="stylesheet" href="/css/style.css">
<nav class="main-nav">
	
	    <a href="/">← Home</a>
	
	
	    <a href="/about/">About</a>
	
	    <a href="/archives/">Archives</a>
	
</nav>


<section id="wrapper">
    <article class="post">
    <header>
        
            <h1>2-3查找树</h1>
        
        <h2 class="headline">Aug 08 2016
        
            
            <a href="/categories/Algorithm/#Algorithm">Algorithm</a>
        
        </h2>
    </header>
</article>
<section id="post-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在随机分布的情况下，<strong>二叉查找树已经具有很好的性能，只不过在最坏（有序）的情况下性能还是比较糟糕</strong>。在本文中我们会学习一种二分查找树并能保证无论如何构造它，它的运行时间都是对数级别的。理想情况下我们希望能够保持二分查找树的平衡性。在一棵含有N个结点的树中，我们希望树高为～lgN，这样我们就能够保持所有查找能在～lgN次比较内结束。然而在二叉查找树插入时要保持树的完美平衡的代价太高了。今天要学习的<strong>2-3查找树</strong>能够实现<strong>插入时保持完美平衡</strong>，能够保证符号表API中所有操作（范围查找除外）均能够在对数时间内完成。</p>
<h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><p>为了保证查找树的平衡性，我们需要对二叉查找树进行一些改造，允许树中的一个结点保存多个键。我们把一棵标准的二叉查找树的结点成为2-结点（含有一个键和两条链接），而现在我们引入3-结点，它含有两个键和三条链接。2-结点和3-结点中的每条链接都对应着其中保存的键所分割产生的一个区别。如下图所示：</p>
<p><img src="/image/23tree-anatomy.png" alt="2-3查找树示意图"></p>
<p>以上图的EJ结点为例，它有两个键和三条链接，AC小于E、H大于E小于J、L大于J，这就是一个3-结点。</p>
<blockquote>
<p><strong>定义</strong>：一棵2-3查找树或为一棵空树，或由以下结点组成：</p>
<ul>
<li>2-结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接的键都大于该结点。</li>
<li>3-结点，含有两个键和三条链接，左链接指向的2-3树中的键都小于该结点，中链接的键都位于该结点两个键之间，右链接的键都大于该结点。</li>
</ul>
</blockquote>
<p>一棵<strong>完美</strong>平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p>
<p>现在，我们已经理解了2-3查找树的定义，那么<strong>2-3查找树是如何在插入时保持完美平衡</strong>？，请试着带着这个问题往下学习，因为这就是今天的重点。</p>
<a id="more"></a>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。先和根结点中的键比较，如果和其中任意一个相等，则查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如下图：</p>
<p><img src="/image/23tree-search.png" alt="2-3树中的查找命中（左）和未命中（右）"></p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>插入操作的情况会比较多，在学习完插入操作之后就会明白为什么2-3查找树中插入元素能够保持完美平衡。</p>
<h3 id="向2-结点插入新键"><a href="#向2-结点插入新键" class="headerlink" title="向2-结点插入新键"></a>向2-结点插入新键</h3><p>要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的插入，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果查找未命中的查找结束于一个2-结点，事情就好办了：<strong>我们只要把这个2-结点替换为一个3-结点，将要插入的键保持在其中即可（如下图）</strong>。如果未命中的查找结束于一个3-结点，事情就要麻烦一些。</p>
<p><img src="/image/23tree-insert2.png" alt="向2-结点中插入新的键"></p>
<h3 id="向一棵只含有一个3-结点的树中插入新键"><a href="#向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="向一棵只含有一个3-结点的树中插入新键"></a>向一棵只含有一个3-结点的树中插入新键</h3><p>在考虑一般情况之前，先假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这也是我一直以来推崇的学习方法，先简单化再一般化。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。所以我们需要先假设插入变成一个4-结点，然后再提取中值键出来当做父结点，如下图所示。这棵树既是含有3个结点的二叉查找树，同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为0，插入后树的高度为1。这个例子很简单但却值得学习，他说明了2-3树是如何生长的。你会发现<strong>2-3查找树是由下向上生长的，跟二叉查找树正好相反</strong>，这也是为什么它插入时能够保持完美平衡的原因，在后面更加一般化的情况下将会更加清晰地理解这个问题。</p>
<p><img src="/image/23tree-insert3a.png" alt="向一棵只含有一个3-结点的树中插入新键"></p>
<h3 id="向一个父结点为2-结点的3-结点中插入新键"><a href="#向一个父结点为2-结点的3-结点中插入新键" class="headerlink" title="向一个父结点为2-结点的3-结点中插入新键"></a>向一个父结点为2-结点的3-结点中插入新键</h3><p>假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这中情况下我们需要<strong>在维持树的完美平衡的前提下为新键腾出空间。</strong>其实跟上面的情况差不多，也是将中值键提取到父结点中，只是现在的父结点存在并且是一个2-结点，直接插入就行了。这样树依然是有序的，并且还是完美平衡的。如下图所示：</p>
<p><img src="/image/23tree-insert3b.png" alt="向一个父结点为2-结点的3-结点中插入新键"></p>
<h3 id="向一个父结点为3-结点的3-结点中插入新键"><a href="#向一个父结点为3-结点的3-结点中插入新键" class="headerlink" title="向一个父结点为3-结点的3-结点中插入新键"></a>向一个父结点为3-结点的3-结点中插入新键</h3><p>如果父结点也是一个3-结点，那就继续分解提出即可。因此这可以推广到一般情况，不断地分解直到遇到一个2-结点或是达到3-结点的根（此时需要分解根结点）。如下图所示：</p>
<p><img src="/image/23tree-insert3c.png" alt="向一个父结点为3-结点的3-结点中插入新键"></p>
<h3 id="分解根结点"><a href="#分解根结点" class="headerlink" title="分解根结点"></a>分解根结点</h3><p>如果从插入结点到根结点的路径上全都是3-结点，此时我们可以按照向一棵只有一个3-结点的树中插入新键的方法处理这个问题。这时树的高度会加1，并且树仍然完美平衡。如下图所示：</p>
<p><img src="/image/23tree-split.png" alt="分解根结点"></p>
<h3 id="局部变换"><a href="#局部变换" class="headerlink" title="局部变换"></a>局部变换</h3><p>2-3树插入算法的根本在于这些变换都是局部的：<strong>除了相关的结点和链接之外不必修改或者检查树的其他部分</strong>。每次变换中，变更的链接数量不会超过很小的常数。需要特别指出的是，不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p>
<h3 id="全局性质"><a href="#全局性质" class="headerlink" title="全局性质"></a>全局性质</h3><p>这些局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。通过上面几种插入形式的学习，发现<strong>只有在根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1</strong>，其他情况都是不变的。</p>
<h2 id="2-3树的生长"><a href="#2-3树的生长" class="headerlink" title="2-3树的生长"></a>2-3树的生长</h2><p>通过上面的学习，我想你应该能够回答开篇提出的问题，为什么2-3查找树在插入时能够保持完美平衡？如果你还是不知道，我们就用二叉查找树的最坏情况来举例构造一棵2-3查找树。下面是我自己手绘的一幅升序插入构造2-3查找树的过程：</p>
<p><img src="/image/23tree-growth" alt="升序插入，构造2-3查找树"></p>
<p>从上图可知，二叉查找树的最坏情况，放到2-3查找树中也能保证对数级别，因为它构造出来的2-3查找树是完美平衡的。</p>
<blockquote>
<p>结论：在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们学习了2-3查找树，它能够在插入元素时保持完美平衡，弥补了二叉查找树最坏情况的缺陷，使符号表API的各种操作（除范围查找外）都达到了对数级别。</p>
<p>然而，我们离真正实现符号表API还有一段距离，尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变化所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为要处理的情况是在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其它信息从一种结点复制到另外一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比表中的二叉查找树更慢。</p>
<p>因此，直接用2-3查找树实现符号表API是不可取的，但是我们只需要对其进行一点点修改变通就能够用二叉查找树几乎一样的代码实现符号表的API，这就是下篇文章即将学习的<strong>红黑树</strong>。</p>
</section>
    
        
        <h2 class="footline">
            <a href="/tags/Algorithm/#Algorithm">Algorithm</a>
        </h2>
    

    <footer id="post-meta" class="clearfix">
        <a href="/about/">
        <img class="avatar" src="/images/avatar.png">
        <div>
            <span class="dark">Rason&#39;s Blog</span>
            <span></span>
        </div>
        </a>
        <section id="sharing">
            <a title="Share to Twitter" class="twitter" href="https://twitter.com/intent/tweet?text=http://ideajava.com/2016/08/08/2-3-search-tree/ - 2-3查找树 @"><span class="icon-twitter">tweet</span></a>
            <a title="Share to Facebook" class="facebook" href="#" onclick="
                window.open(
                  'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
                  'facebook-share-dialog',
                  'width=626,height=436');
                return false;"><span class="icon-facebook-sign">Share</span>
            </a>
        </section>
    </footer>


	<footer id="footer">
	<div id="social">
		<p class="small">©  rason| Powered by Hexo 
	
	<a href="http://www.beian.miit.gov.cn" target="_blank">粤ICP备17046371号-1</a></p>
	</div>
</footer>

</section>

	<script src="//cdnjs.loli.net/ajax/libs/instantclick/3.0.1/instantclick.min.js" data-no-instant=""></script>
	<script data-no-instant="">
		
		InstantClick.init('mousedown');
	</script>



